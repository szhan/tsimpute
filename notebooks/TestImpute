{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import msprime\n",
    "import tsinfer\n",
    "import tskit\n",
    "import numpy as np\n",
    "\n",
    "ts = msprime.sim_ancestry(10, sequence_length=10000, ploidy=1, random_seed=1)\n",
    "ts = msprime.sim_mutations(ts, rate=0.1, random_seed=1)\n",
    "tables = ts.dump_tables() # remove populations, which tsinfer doesn't seem to like\n",
    "tables.populations.clear()\n",
    "tables.nodes.population = np.full_like(tables.nodes.population, tskit.NULL)\n",
    "ts = tables.tree_sequence()\n",
    "print(ts.num_sites, \"sites simulated\")\n",
    "\n",
    "# Use the tree seq from the first 5 samples\n",
    "ts_ref = ts.simplify(np.arange(5), filter_sites=False)\n",
    "# Use the undocumented \"make_ancestors_ts\" function.\n",
    "ts_anc = tsinfer.eval_util.make_ancestors_ts(ts=ts_ref, samples=None)\n",
    "sd = tsinfer.SampleData.from_tree_sequence(ts)\n",
    "sd_query = sd.subset(individuals=np.arange(5))\n",
    "# here you might want to mark some sites as all missing\n",
    "num_missing_sites = 20\n",
    "impute_sites = np.random.choice(\n",
    "    np.arange(sd_query.num_sites),\n",
    "    num_missing_sites,\n",
    "    replace=False,\n",
    ")\n",
    "\n",
    "sd_query_miss = sd_query.copy()  # make an editable copy\n",
    "for v in sd_query.variants():\n",
    "    if v.site.id in impute_sites:\n",
    "        sd_query_miss.sites_genotypes[v.site.id] = np.full_like(v.genotypes, tskit.MISSING_DATA)\n",
    "sd_query_miss.finalise()\n",
    "\n",
    "# check all the sites in anc_ts are also in sd_query\n",
    "assert set(ts_anc.tables.sites.position).issubset(set(sd_query.sites_position[:]))\n",
    "print(ts_anc.num_sites, \"sites in anc_ts.\", sd_query.num_sites, \"in sd_query\")\n",
    "\n",
    "# all alleles in the anc_ts should be biallelic. There may be some in which\n",
    "# the query set has extra alleles. If so, we can't do anything with them, and\n",
    "# so should mark these allelic states as missing data (probably!)\n",
    "new_sd_query = sd_query_miss.copy()  # make an editable copy\n",
    "sd_variants = sd_query_miss.variants()\n",
    "sd_var = next(sd_variants)\n",
    "for ref_site in ts_anc.sites():\n",
    "    while sd_var.site.position != ref_site.position:\n",
    "        # we don't have to mess with sites in sd that aren't in anc_ts \n",
    "        sd_var = next(sd_variants)\n",
    "    site_id = sd_var.site.id\n",
    "    assert len(ref_site.alleles) == 2\n",
    "    derived_allele = ref_site.alleles - {ref_site.ancestral_state}\n",
    "    assert len(derived_allele) == 1\n",
    "    derived_allele = tuple(derived_allele)[0]\n",
    "    # make sure that the sample data file uses 1 for the derived allele, and mark others as missing\n",
    "    assert ref_site.ancestral_state == sd_var.alleles[0]\n",
    "    if derived_allele not in sd_var.alleles:\n",
    "        # all derived alleles in the sd file should be marked as missing, because\n",
    "        # none match the derived allele in the ancestors ts\n",
    "        new_sd_query.sites_genotypes[site_id] = np.where(\n",
    "            sd_var.genotypes != 0,\n",
    "            tskit.NULL,  # flag all non-ancestral as missing\n",
    "            0,\n",
    "        )\n",
    "        print(\"Site\", site_id, \"has no matching derived alleles in the query set\")\n",
    "        new_sd_query.sites_alleles[site_id] = [ref_site.ancestral_state]\n",
    "    else:\n",
    "        derived_allele_index = sd_var.alleles.index(derived_allele)\n",
    "        if derived_allele_index == 1:\n",
    "            if len(sd_var.alleles) == 2:\n",
    "                continue  # everything aligns, nothing to do\n",
    "            # Just need to mark alleles > 1 as missing\n",
    "            new_sd_query.sites_genotypes[site_id] = np.where(\n",
    "                sd_var.genotypes > 1,\n",
    "                tskit.NULL,  # flag all non-ancestral as missing\n",
    "                sd_var.genotypes,\n",
    "            )\n",
    "            print(\"Site\", site_id, \"has extra derived alleles in the query set, which have been set missing\")\n",
    "\n",
    "        else:\n",
    "            # a bit more complicated: we need to reorder the alleles in the sd file\n",
    "            # so that the first is the one in the ancestors ts\n",
    "            new_sd_query.sites_genotypes[site_id] = np.where(\n",
    "                sd_var.genotypes == 0,\n",
    "                0,\n",
    "                np.where(sd_var.genotypes == derived_allele_index, 1, tskit.NULL)\n",
    "            )\n",
    "            print(\"Site\", site_id, \"has the target derived allele at a different index\")\n",
    "        # Make all the allele lists biallelic\n",
    "        new_sd_query.sites_alleles[site_id] = [ref_site.ancestral_state, derived_allele]\n",
    "    \n",
    "new_sd_query.finalise()\n",
    "# Check all the ts_anc sites are now mono or biallelic in sd\n",
    "p = set(s.position for s in ts_anc.sites())\n",
    "for s in new_sd_query.sites():\n",
    "    if s.position in p:\n",
    "        if len(s.alleles) > 2:\n",
    "            print(\"BAD SITE:\", s.id, \"has more than 2 alleles:\", s.alleles)\n",
    "\n",
    "\n",
    "ref_matched_ts = tsinfer.match_samples(new_sd_query, ts_anc)\n",
    "for v_orig, v_imputed in zip(sd_query.variants(), ref_matched_ts.variants()):\n",
    "    assert v_orig.site.position == v_imputed.site.position\n",
    "    # here we assume that the samples are in the same order\n",
    "    if v_orig.site.id in impute_sites:\n",
    "        a_orig = np.array(v_orig.alleles)\n",
    "        a_imputed = np.array(v_imputed.alleles)\n",
    "        print(\"Original\", a_orig[v_orig.genotypes])\n",
    "        print(\"Imputed \", a_imputed[v_imputed.genotypes])\n",
    "        print(\" - \")\n",
    "\n",
    "        "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
